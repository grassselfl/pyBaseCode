文件



程序正常退出可自动关闭文件

编解码，所有的文件都是二进制文件，即字节流，但是二进制文件一些特殊的可以是文本文件，即字符流


```python
"""
文件操作
"""

f = open('../file.txt', mode='r', encoding='utf-8')  # 以什么方式编码，就以什么方式打开
data = f.read()
print(data)
f.close()

# r，只读
# rb，二进制只读
# w，无该文件会新建,有该文件
# wb
# a 追加写入
# ab
f = open('../file.txt', mode='r', encoding='utf-8')
data = f.write("不念过往,不畏将来")
print(data)
f.close()

# f.seek(0)

# 读模式
# r
# 打开不存在的文件会报错、不能写；如不指定模式则默认是r
# 写模式
# w
# 打开不存在的文件会, 会新建一个文件；打开存在的文件会先清空后覆盖原有文件；不能读
# 追加模式
# a
# 打开不存在的文件会, 会新建一个文件；不能读
#
# 读写模式
# r + 能写，打开不存在的文件会报错,r+b
# 写读模式
# w + 能读，但是读不到内容，因为w先把文件内容清空了,w+b
# 追加读模式
# a + 能读，但读不到内容，因为文件指针默认在最后一行，可用seek移动文件指针位置,a+b


# f.read(3)  # 按照字符
# f.seek(3)  # 按照字节,具体看编码方式
# f.readline()
# f.readlines() # list
f.readable()
f.tell()  # 光标位置
# f.truncate(3)  # 注意

with open('../file.txt', mode='r', encoding='utf-8') as obj:
    print(obj.read())
# r+ w+区别
```

```python
# 序列化
# json
import json

#


d = {1: "a", 2: "b"}
print(d, type(d))
d_dump = json.dumps(d)
print(d_dump, type(d_dump))
d_rd = json.loads(d_dump)
print(d_rd, type(d_rd))

d = {1: "细节", 2: "b"}
f = open("../dump.txt", "w", encoding="utf-8")
json.dump(d, f, ensure_ascii=False)
f.close()

f = open("../dump.txt", encoding="utf-8")
d = json.load(f)
f.close()
print(d, type(d))

# 小例子
l = [{'a': 1}, {'b': 2}, {'c': 3}]
f = open("../file", "w")
for d in l:
    print(d, type(d))
    str_dict = json.dumps(d)
    f.write(str_dict + "\n")
f.close()

f = open("../file")
l = []
for line in f:
    d = json.loads(line.strip())
    l.append(d)
f.close()
print(l)




# 二进制存储，不支持分词load
import pickle

d = {1: "a", 2: "b"}
print(d, type(d))
d_dump = pickle.dumps(d)
print(d_dump, type(d_dump))
d_rd = pickle.loads(d_dump)
print(d_rd, type(d_rd))

d = {1: "细节", 2: "b"}
f = open("../dump.txt", "wb")
pickle.dump(d, f)
f.close()

f = open("../dump.txt", "rb")
d = pickle.load(f)
f.close()
print(d, type(d))


import shelve
f = shelve.open('open_file')
f['key'] = {'int':11,'float':1.2,'string':'ssd'}
f.close()

f = shelve.open('open_file',flag='r')
e = f['key']
f.close()
print(e) 
```

```python
# configparse
import configparser

# 写

config = configparser.ConfigParser()
config["DEFAULT"] = {
    "ServerAliveInterval": 45,
    "Compression": "yes"
}
config["bitbucket.org"] = {"user": "da"}

with open('../config.ini', 'w') as configfile:
    config.write(configfile)

# 读

config = configparser.ConfigParser()
config.read('config.ini')
print(config.sections())
print("bitbucket.org" in config)
print("b.org" in config)
print(config["bitbucket.org"]["user"])
print(config["DEFAULT"]["Compression"])
# print(config["DEFAULT"]["C"])#没有的会报错

config.add_section("add-section")
config.remove_section("bitbucket.org")
config.set("add-section", "k1", "111")
config.set("add-section", "k2", "222")
f = open("../newconfig.ini", 'w')
config.write(f)
f.close()

```


```python
# IO模型


# 同步、异步、阻塞、非阻塞
# 同步阻塞
# 同步非阻塞
# 异步阻塞
# 异步非阻塞

# 先入为主将阻塞非阻塞作为实现同步和异步的手段，而实际上，阻塞非阻塞与同步异步是两种不同范畴的内容

# 五种模型 对号入座 进行分类


# selectors包
```