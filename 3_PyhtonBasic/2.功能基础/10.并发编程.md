```python
"""
多进程
启动一个进程
"""
import os
import time
from multiprocessing import Process


def func(args, io):  # 元组元素与函数参数对应
    print(args)


if __name__ == "__main__":
    p = Process(target=func, args=('lm', 12))
    p.start()
    print(os.getpid())  # 任务管理器详细信息可以查看PID
    print(os.getppid())

```

```python
"""
多进程
启动一个守护进程
"""
from multiprocessing import Process


def func(i):
    print(i * '*')


if __name__ == "__main__":
    p_list = []
    for i in range(1, 11):
        p = Process(target=func, args=(i,))  # daemon守护进程，python中主进程需要等待子进程结束后再结束
        p_list.append(p)
        p.start()
        # p.terminate() #结束子进程
    [p.join() for p in p_list]
    print("over")

```

```python
"""
多进程
启动一个进程
"""

from multiprocessing import Process


class ProcessDemo(Process):
    def run(self) -> None:
        print(12345)


if __name__ == "__main__":  # 为什么python创建进程需要使用主函数，否则就报错
    p = ProcessDemo()
    p.start()

```

```python
"""
多进程
信号量
"""

from multiprocessing import Semaphore

sem = Semaphore(4)
sem.acquire()
sem.acquire()
sem.acquire()
sem.acquire()
sem.acquire()
sem.release()
```

```python
"""
多进程
事件
"""
from multiprocessing import Event

e = Event()  # 通过socket通信？？
print(e.is_set())
e.set()
print(e.is_set())
e.clear()
print(e.is_set())
e.wait(3)
print("12345")



```


```python
"""
多进程
红绿灯例子
"""

import random
import time
from multiprocessing import Event, Process


def car_process(e, i):
    if not e.is_set():
        print("car%i在等待" % i)
        e.wait()
    print("\033[0;32;40mcar%i通过\033[0m" % i)


def light_process(e):
    while True:
        if not e.is_set():
            time.sleep(5)
            e.set()
            print("\033[32m绿灯亮了\033[0m")
        else:
            time.sleep(2)
            e.clear()
            print("\033[31m红灯亮了\033[0m")



if __name__ == "__main__":
    e = Event()
    traffic = Process(target=light_process, args=(e,))
    traffic.start()
    for i in range(20):
        car = Process(target=car_process, args=(e, i))
        car.start()
        time.sleep(random.random())

```

```python
"""
多进程
Queue
"""
from multiprocessing import Queue, Process  # 进程安全？

def producer(q):
    q.put("food")
def consumer(q):
    q.get()

if __name__ == "__main__":
    q = Queue()
    p = Process(target=producer,args=(q,))
    c = Process(target=consumer,args=(q,))
    p.start()
    c.start()
```

```python
"""
多进程
JoinableQueue
"""
import time
import random
from multiprocessing import JoinableQueue, Process


def producer(q, name, food):
    for i in range(5):
        time.sleep(random.random())
        fd = '%s%s' % (food, i + 1)
        q.put(fd)
        print('%s生产了一个%s' % (name, food))
    q.join()  # (3)生产者for循环生产完所有产品，需要q.join()阻塞一下，对这个队列进行阻塞。


# (5)我启动了生产者之后，生产者函数一直在生成数据，直到生产完所有数据将队列q.join()一下，意思是当我生产的数据都被消费者消费完之后 队列的阻塞才结束。
def consumer(q, name):  # (1)消费者不需要像Queue那样判断从队列里拿到None再退出执行消费者函数了
    while True:
        food = q.get()
        time.sleep(random.random())
        print('%s吃了%s' % (name, food))
        q.task_done()  # (2)消费者每次从队列里面q.get()一个数据，处理过后就使用队列.task_done()


if __name__ == '__main__':
    jq = JoinableQueue()
    p = Process(target=producer, args=(jq, '喜洋洋', '包子'))  #
    p.start()  # (4)启动一个生产者，启动一个消费者，并且这个消费者做成守护进程，然后生产者需要p.join()阻塞一下。
    c = Process(target=consumer, args=(jq, '灰太狼'))
    c.daemon = True  #
    c.start()
    p.join()

```

```python
# pipe，管道进程不安全
```

```python
"""
多进程
Manager
"""

from multiprocessing import Manager, Process


# Manager中一些数据类型是进程不安全的
def main(dic):
    dic['count'] -= 1
    print(dic)


if __name__ == "__main__":
    m = Manager()
    dic = m.dict({'count': 100})
    p = Process(target=main, args=(dic,))
    p.start()
    p.join()
    print("主进程", dic)

# 进程通信，IPC


```

```python
"""
多进程
进程池
"""

import os
import time
from multiprocessing import Pool


def func(n):
    print("start func%s" %n,os.getpid())
    time.sleep(1)
    print("end func%s" %n, os.getpid())


if __name__ == "__main__":
    p = Pool(5)
    for i in range(10):
        p.apply(func,args=(i,))#同步提交
        p.apply_async(func,args=(i,))
    p.close() # 关闭任务接受
    p.join()# 同步进程任务结束
    # p.terminate()
```
```python
"""
多进程
进程池、回调函数
"""

# 回调函数
import os
from multiprocessing import Pool


def func1(n):
    print("in func1")
    print(n, os.getpid())
    return n


def func2(n):
    print("in func2")
    print(n * n, os.getpid())
    return n * n


if __name__ == "__main__":
    print(os.getpid())
    p = Pool(5)
    # for i in range():
    p.apply_async(func1, args=(10,), callback=func2)
    p.close()
    p.join()
    # p.map()自带close和join
# 回调函数是在主进程进行执行的

```

```python
"""
多线程
"""

# 线程
# 用户级线程、内核级线程
import os
import time
from threading import Thread


def func(n):
    time.sleep(1)
    print(n,os.getpid())

for i in range(10):
    t = Thread(target=func, args=(i,))
    t.start()

```

```python
# 线程
# 用户级线程、内核级线程
import os
import time
from multiprocessing import Process


def func(n):
    time.sleep(1)
    print(n,os.getpid())

if __name__ == "__main__":
    for i in range(10):
        t = Process(target=func, args=(i,))
        t.start()

```

```python
import time
from threading import Thread


class ThreadDemo(Thread):
    def __init__(self, args):
        super().__init__()
        self.args = args

    def run(self) -> None:
        time.sleep(1)
        print(self.args)


t = ThreadDemo((1,2))
t.start()

```

```python
import os
from threading import Thread


def func(a, b):
    global g
    g = 0
    print(g, os.getpid())


g = 100
f = g
t_list = []
for i in range(10):
    t = Thread(target=func, args=(i, 5))
    t.start()
    t_list.append(t)
for t in t_list: t.join()
print(g)
print(g, f)
# 全局变量在多个线程之间共享

```

```python
# GIL 全局解释器锁 Global Interpreter Lock
# CPython解释器中 在CPython解释器中执行的每一个Python线程，都会先锁住自己，以阻止别的线程执行
# 解释型语言本身问题
# CPython不支持并行，仅支持并发
# 在CPython解释器下的Python程序，同一时刻某一进程下的多个线程中只能有一个线程被CPU执行，即利用不了多核，只能用单核
# 所以要用的话还是用多进程或者分布式计算
# thread包不完善
import threading
import time

print(threading.current_thread())
print(threading.currentThread())
# 命名兼容666

def func():
    print(threading.currentThread())
    print(threading.get_ident())
    time.sleep(1)

for i in range(10):
    t =  threading.Thread(target=func)
    # t.run()#???
    t.setName(i.__str__())
    t.start()
print()
print(threading.active_count())
print(threading.currentThread())
```

```python
# 守护进程 主进程执行完毕守护进程结束
# 守护线程 主线程及非守护子线程结束守护进程结束


# 守护线程

```
```python
# 线程锁
# 递归锁==可重入锁

from threading import Lock, RLock, Condition, Thread

# 信号量
from threading import Semaphore, Event

# Condition
def func(condition,i):
    condition.acquire()
    condition.wait()
    print("在第%s个循环里"%i)
    condition.release()

condition = Condition()
for i in range(10):
    Thread(target=func,args=(condition,i)).start()
while True:
    num = int(input(">>>"))
    condition.acquire()
    condition.notify(num)
    condition.release()
```

```python
# 定时器

import time
from threading import Timer


def func():
    print("时间同步")


while True:
    t = Timer(1, func)
    t.start()
    time.sleep(1)


```

```python
# concurrent
# concurrent是并发包，包含多进程和多线程的各种工具，包括进程池、线程池
import time
from concurrent.futures import ThreadPoolExecutor


def func(n):
    time.sleep(2)
    return n * n

def call_back(n):
    print("结果是"+n.result().__str__())

tpool = ThreadPoolExecutor()
t_list = []
for i in range(20):
    t = tpool.submit(func,i)
    t.add_done_callback(call_back)
    t_list.append(t)

# tpool.shutdown()#可以不等部分获取结果
print("主线程")
for t in t_list:print(t.result())

import asyncio
```

```python
"""
协程
"""

# 协程
# 轻量级线程、用户级线程
# 在单线程下完成任务，但是多个任务交替进行规避IO浪费
# 代码单纯发出指令？？？CPU发出，具体设备执行耗时

# yield实现携程
import time


def eat():
    while True:
        print("eat")
        yield
        time.sleep(0.5)


def drink():
    while True:
        print("drink")
        yield
        time.sleep(0.5)


if __name__ == "__main__":
    e = eat()
    d = drink()
    while True:
        e.__next__()
        d.__next__()

```

```python
"""
greenlet
"""
from greenlet import greenlet


def eat():
    while True:
        print("eat")
        gl2.switch()


def drink():
    while True:
        print("drink")
        gl1.switch()


if __name__ == "__main__":
    gl1 = greenlet(run=eat)
    gl2 = greenlet(run=drink)
    gl1.switch()  # 没有运行会先运行run

```

```python
"""
gevent
"""

import threading

from gevent import monkey

import time
import gevent

monkey.patch_all()


def eat():
    while True:
        print("eat", threading.current_thread().name, threading.current_thread())
        time.sleep(0.5)


def drink():
    while True:
        print("drink", threading.current_thread().name, threading.current_thread())
        time.sleep(0.5)


if __name__ == "__main__":
    g1 = gevent.spawn(eat)
    g2 = gevent.spawn(drink)
    g1.join()
    g2.join()
# 协程由用户进行切换，该过程对操作系统透明

```


```python
js

async的内部实现原理就是如果该函数中有一个返回值，当调用该函数时，默认会在内部调用Promise.solve() 方法把它转化成一个Promise 对象作为返回，
若函数内部抛出错误，则调用Promise.reject()返回一个Promise 对象

await即等待，用于等待一个Promise对象。它只能在异步函数 async function中使用，否则会报错
它的返回值不是Promise对象而是Promise对象处理之后的结果
await表达式会暂停当前 async function的执行，等待Promise 处理完成。若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行 async function，若 Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。​如果 await 操作符后的表达式的值不是一个 Promise，那么该值将被转换为一个已正常处理的 Promise。

与Promise对比
1、不再需要多层.then方法
假设一个业务分很多步骤完成，并且每个步骤都是异步，依赖上一个步骤的结果。





py

关于协程的语法糖async和await


在3.5过后，我们可以使用async修饰将普通函数和生成器函数包装成异步函数和异步生成器

现在知道，完成异步的代码不一定要用async/await，使用了async/await的代码也不一定能做到异步，async/await是协程的语法糖，使协程之间的调用变得更加清晰，使用async修饰的函数调用时会返回一个协程对象，await只能放在async修饰的函数里面使用，await后面必须要跟着一个协程对象或Awaitable，await的目的是等待协程控制流的返回，而实现暂停并挂起函数的操作是yield。
```