```python
"""
类和对象
函数和变量
方法与属性

"""

class Person:
    uuid = 1
    def __init__(self, name, age, sex):
        print(self.__dict__)
        self.name = name
        self.age = age
        self.sex = sex

    def walk(self, n):
        print(self.name + "走路" + str(n) + "步")

    def run(s):
        print(str(s) + "跑路")


p = Person("张三", 18, "男")
print(p.__dict__)
print(p.__class__)
print(object.__class__)
print(Person.__dict__)
Person.walk(p, 5)  # 关注过程
p.walk(5)  # 关注对象

Person.run("p")
p.run()



# python实例化，会创建self以调用__init__方法

p.__dict__['name'] = 'zhangsan'
print(p.__dict__['name'])
Person.uuid=2
print(Person.uuid)

# 对象可以通过__dict__进行更改，但是类不能通过__dict__进行更改，都可以通过.进行访问

# 类有自己的命名空间、对象有自己的命名空间
```

```python
# python机制下类属性的特殊点
class Person:
    uuid = 1
    s = [1, 2, 3]

    def __init__(self):
        pass


a = Person()
b = Person()
print(a.uuid, b.uuid, Person.uuid)

Person.uuid = 2
print(a.uuid, b.uuid, Person.uuid)

a.uuid = 3  # 此时py会在对象中创建新的属性uuid
b.uuid = 4  # 此时py会在对象中创建新的属性uuid
print(a.uuid, b.uuid, Person.uuid)

del a.uuid, b.uuid  # 除非删除对象中的uuid
print(a.uuid, b.uuid, Person.uuid)
# 也正是由于这种原因有时候对象会偷偷多出来许多类中不曾有的属性


# 指针
a.s[0:1] = '1'
print(Person.s)

```

```python
# python机制下方法的特殊点

class Person:
    uuid = 1
    s = [1, 2, 3]

    def func(self): pass


a = Person()
b = Person()

print(id(a.uuid), id(b.uuid))


def func(): pass


print(func)
print(Person.func)
print(a.func)  # 绑定方法，表示要把对象a的数据传递给func
print(a)

# 绑定方法与非绑定方法
# 凡是类中的方法和函数，都是绑定给对象使用的；
#
# 　　　　2.绑定方法都有自动传值的功能。传递进去的值，就是对象本身。
#
# 　　　　3.如果类想调用绑定方法，就必须遵循函数的参数规则，有几个参数，就必须传递几个参数


# 既然类中的方法，默认都是绑定给对象使用，那么，我们要采取一点措施，将类中的绑定方法解除对象绑定关系，进而绑定到类上。
# 在python中，引入了@classmethod方法，将类中的方法绑定到类身上


# 从上述结果可以看出，我们加上了一个装饰器，将类中绑定给对象的方法，绑定到类身上了。我们之前分析过，如果一个方法绑定到谁身上，
# 那么在调用该函数的时候，将自动将该调用者当作第一个参数传递到函数中。但是，绑定到类的方法与绑定到对象方法有一点点不同
# 当对象在调用类的绑定方法时，也会默认把类当作参数传递进去


# 从上面的输出结果，我们可以看出，使用了@staticmethod装饰了一个函数，
# 那么这个函数跟普通函数没有什么区别。既然是普通函数，那么就遵从函数参数传递规则，有几个参数就传递几个参数

# 原来这就是classmethod和staticmethod的区别


```

```python
"""
python访问控制权限
私有属性与私有方法
"""


class A:
    __uuid = 1
    def __init__(self, a, a1):
        self.a = a
        self.__a1 = a1

    def get_a1(self):
        print(self.__dict__)
        self.__func()
        return self.__a1

    def __func(self):
        print("私有方法__func")

o = A(1, 2)
print(o.a)
print(o._A__a1)
print(o.get_a1())
o.__a2 = 3
print(o.__a2)
print(o.__dict__)  # _A转换只在内部进行。不能直接调用是因为这个自动转换
print(A.__dict__)
o._A__func()


# python类的访问权限控制，python只分为public和private，用__进行区分
# 类静态属性
# 类属性
# 类方法

# _类名__名字
```

```python
"""
适用于类中方法的一些装饰器
"""
from math import pi


class Circle:
    def __init__(self, r):
        self.r = r

    @property
    def length(self):
        return pi * 2 * self.r

    @length.setter
    def length(self,l):
        print(l)


    @property
    def n(self):
        pass

    def area(self):
        return pi * self.r ** 2


c = Circle(1)
print(c.area())
print(c.length)
print(c.n)  # 会报错
print(c.__dict__)
print(Circle.__dict__)
c.length = 1  # 不能直接修改，需要借助另一个装饰器函数，尽管这里实质是调用函数，并未进行赋值
print(c.length)



# 自己把自己封了起来，又通过装饰器函数解开，相当于能换个名字。。

```

```python
"""
静态方法与类方法
"""
class A:
    a = 1

    def change1(self, a):  # 显然不合理
        A.a = a

    def change2(a):  # 可行，但不规范
        A.a = a

    @classmethod
    def change3(cls, a):  # cla表示一个类对象，是类对象的默认参数
        cls.a = a

    @staticmethod
    def change4(a):
        A.a = a

    @staticmethod
    def change5(a):
        return a


A.change3(4)
print(A.change5(5))

# python中类方法和静态方法不一样

# 同样也可以用对象调用类方法和静态方法
o = A()
o.change3(3)
o.change4(4)

```

```python
"""
反射
"""

class A:
    a = 1



    @classmethod
    def func1(cls):
        print(1)

    @staticmethod
    def func2(a):
        print(a)


    def func3(self):
        print(3)

a = getattr(A, 'a')
print(a)
delattr(A, 'a')
print(hasattr(A, 'a'))

print(hasattr(A, 'func1'))
method = getattr(A, 'func1')
method()

print(hasattr(A, 'func2'))
method = getattr(A, 'func2')
method(2)

# 上述是类级别的反射，可以用类反射到一般方法，但是逃不过self参数

# 下面是对象级别的反射

a = A()
print(hasattr(a, 'func3'))
method = getattr(a, 'func3')
method()# 此时才可以忽略参数self


# 通过反射
# 对象名 获取对象属性 和 普通方法
# 类名 获取静态属性 和 类方法 和 静态方法
```

```python
# 反射进阶
# setattr、getattr、hasattr、delattr
s = 10
class A:
    a = 1
    def func(self):
        print(1)

    @classmethod
    def func1(cls):
        print(2)

    @staticmethod
    def func2():
        print(3)
print(A.__dict__)

# 下述方式很相似于反射
print(A.__dict__['a'])
A.__dict__['func'](A())

# 这里似乎不能直接用字典调用该方法，因为使用了装饰器？？

# A.__dict__['func1'](A)#TypeError: 'classmethod' object is not callable

# A.__dict__['func2']()#TypeError: 'staticmethod' object is not callable

# python中反射分为对对象的反射和对类的反射，两者是不一样的，对类可以反射类属性、静态方法、类方法，对对象可以反射，对象属性、对象方法

```

```python
"""
实例化链
"""
class A:
    def __init__(self):
        print("A __init__")
        self.func()
    def func(self):
        print("A func")

class B(A):
    def func(self):
        print("B func")

b= B() # 显然使用继承的__init__方法，调用的自己的func

print(b.__dict__)
print(B.__dict__)
print(A.__dict__)
```

```python
"""
实例化链
"""
# py继承中的一个十分开放的问题

class A:
    def __init__(self, a):
        self.a = a
    def func(self):
        print("A")

class B(A):
    def __init__(self,b):
        self.b = b

b = B(2)
b.func()

# 实例化链可以打断
# 上述程序完全没有问题，尽管没有初始化b.a，也能调用A的方法func，说明继承关系是真的，但却可以没有实例化链，这一点说明了py十分开放


class C:
    def __init__(self, c):
        self.c = c

class D(C):
    def __init__(self,c,d):
        super().__init__(c)
        self.d = d


d = D(1,2)

# 实例化链
```


```python
"""
抽象、继承、封装、多态
开始处理多继承问题
"""

class A:
    def __init__(self, a):
        self.a = a


class B:
    def __init__(self, b):
        self.b = b

    def func(self):
        print("func")


class C(A, B):
    pass


class D(A):
    def __init__(self, a, d):
        A.__init__(self, a)
        self.d = d


class E(B):
    def __init__(self, b, e):
        super().__init__(b)
        self.e = e

    def func(self):
        print("func")


print(A.__bases__)
print(B.__bases__)
print(C.__bases__)

e = E(1, 2)
e.func()
print(e)
super(E, e).func()  # 好像不会提示
# print(super(E, e).)
```

```python
"""
关于多继承的一个解析顺序
"""
class A:
    pass
    # def func(self): print("A")


class B(A):
    def func(self): print("B")


class C(A):
    def func(self): print("C")

class D(B,C):
    pass

d = D()
d.func()# D、B、C、A

# java不能存在这种问题，cpp使用类名限定解决？，py使用就近原则
```

```python
"""
关于多继承的一个解析顺序
"""
# 深入分析study_40问题

class A:
    def func(self): print("A")


class B:
    def func(self): print("B")


class C(A):
    pass
    # def func(self): print("C")


class D(B):
    def func(self): print("D")

class E(C,D):
    pass

e = E()
e.func()  # D、B、C、A
print(E.__mro__)
# java不能存在这种问题，cpp使用类名限定解决？，py使用就近原则（直观上），广度优先（实质上）

```

```python
"""
关于多继承的一个解析顺序
"""
# 深入分析study_41问题

class O:

    def func(self):
        s = "O"
        print(s+"()")
        return s


class A(O):
    def func(self):
        s = "A"
        print(s + "(" + super().func() + ")"+"  （这里好像有问题）")
        return s


class B(O):
    def func(self):
        s = "B"
        print(s + "(" + super().func() + ")")
        return s


class C(A):
    def func(self):
        s = "C"
        print(s + "(" + super().func() + ")")
        return s


class D(B):
    def func(self):
        s = "D"
        print(s + "(" + super().func() + ")")
        return s


class E(C, D):
    def func(self):
        s = "E"
        print(s + "(" + super().func() + ")")
        return s


e = E()
e.func()  # D、B、C、A
print(E.__mro__)
# java不能存在这种问题，cpp使用类名限定解决？，py使用C3算法


# 新式类，旧式类
# C3算法
# py3只有新式类
# py2早期版本是旧式类，后期加入了新式类
# mro 方法解析顺序
# 单继承没有此类问题


# 验证study_52的问题
print(issubclass(A,O))
print(issubclass(A,D))
print(issubclass(E,A))

```

```python
class A:
    pass


class B(A):
    pass


a = A()

print(isinstance(a, A))  # 是否对象
print(issubclass(B, A))  # 是否子类

# 那么有一个mro问题，在study_42验证，并没有出现该问题，mro不愧是方法解析顺序，那么super到底是什么？
#也许issubclass仅仅是单线分析
```

```python
"""
抽象基类
抽象方法
python中无接口概念，毕竟支持多继承，但是有抽象类的概念
"""
from abc import abstractmethod, ABCMeta


# Abstract Base Class
class A(metaclass=ABCMeta):
    @abstractmethod
    def func_1(self):
        pass


class A_1(A):
    def func_1(self):
        pass


a = A_1()

# python中抽象类不能实例化，接口类不能实例化

# python中抽象类可以单继承和多继承，但一般根据相关规范编程

```

```python
"""
多态
"""
# python多态

# python本身便是多态

# 没有向上转型
# 没有重载
```

```python
"""
双下方法
双下方法从属于类和对象，但在类和对象中相对独立，尤其是object类，是对面向对象的方法极大的一种抽象
"""

class object:
    """
    The base class of the class hierarchy.

    When called, it accepts no arguments and returns a new featureless
    instance that has no instance attributes and cannot be given any.
    """

    def __delattr__(self, *args, **kwargs):  # real signature unknown
        """ Implement delattr(self, name). """
        pass

    def __dir__(self, *args, **kwargs):  # real signature unknown
        """ Default dir() implementation. """
        pass

    def __eq__(self, *args, **kwargs):  # real signature unknown
        """ Return self==value. """
        pass

    def __format__(self, *args, **kwargs):  # real signature unknown
        """ Default object formatter. """
        pass

    def __getattribute__(self, *args, **kwargs):  # real signature unknown
        """ Return getattr(self, name). """
        pass

    def __ge__(self, *args, **kwargs):  # real signature unknown
        """ Return self>=value. """
        pass

    def __gt__(self, *args, **kwargs):  # real signature unknown
        """ Return self>value. """
        pass

    def __hash__(self, *args, **kwargs):  # real signature unknown
        """ Return hash(self). """
        pass

    def __init_subclass__(self, *args, **kwargs):  # real signature unknown
        """
        This method is called when a class is subclassed.

        The default implementation does nothing. It may be
        overridden to extend subclasses.
        """
        pass

    def __init__(self):  # known special case of object.__init__
        """ Initialize self.  See help(type(self)) for accurate signature. """
        pass

    def __le__(self, *args, **kwargs):  # real signature unknown
        """ Return self<=value. """
        pass

    def __lt__(self, *args, **kwargs):  # real signature unknown
        """ Return self<value. """
        pass

    @staticmethod  # known case of __new__
    def __new__(cls, *more):  # known special case of object.__new__
        """ Create and return a new object.  See help(type) for accurate signature. """
        pass

    def __ne__(self, *args, **kwargs):  # real signature unknown
        """ Return self!=value. """
        pass

    def __reduce_ex__(self, *args, **kwargs):  # real signature unknown
        """ Helper for pickle. """
        pass

    def __reduce__(self, *args, **kwargs):  # real signature unknown
        """ Helper for pickle. """
        pass

    def __repr__(self, *args, **kwargs):  # real signature unknown
        """ Return repr(self). """
        pass

    def __setattr__(self, *args, **kwargs):  # real signature unknown
        """ Implement setattr(self, name, value). """
        pass

    def __sizeof__(self, *args, **kwargs):  # real signature unknown
        """ Size of object in memory, in bytes. """
        pass

    def __str__(self, *args, **kwargs):  # real signature unknown
        """ Return str(self). """
        pass

    @classmethod  # known case
    def __subclasshook__(cls, subclass):  # known special case of object.__subclasshook__
        """
        Abstract classes can override this to customize issubclass().

        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """
        pass

    __class__ = None  # (!) forward: type, real value is "<class 'type'>"
    __dict__ = {}
    __doc__ = ''
    __module__ = ''
```

```python
o = object()

print(repr(1))  # 实质上在调用该方法的对应双下方法
print(repr('1'))


# 验证

class A:

    def __init__(self,a):
        pass

    def __str__(self):
        return "A is str"

    def __call__(self, *args, **kwargs):
        print("is __call__")

print(str(A(1)))

print(A(1), "1")  # 打印对象本身都是打印__str__的返回值，该返回值必然是一个字符串，所以print本质上是打印的字符串

print(o.__str__())
print(o.__repr__())

# object类方法与builtins方法


# 格式化输出本质是调用的双下方法
# s% str() __str__
# r% repr() __repr__

# 关于print(obj)如果没有__str__，则使用__repr__，没有就找父类，直至object

# str()如果作用对象无__str__实现，就使用__repr__，若只能实现一个，就是先repr，因为str()可以用，repr也可以用

# __len__ len()同理

# len(A())#可以验证

# del执行的是__del__，析构函数？？？，__init__构造函数，所以程序结束时会自动调用析构函数


# 上述就体现出面向过程和面向对象结合的玄妙之处了

a = A(1)
a()

A(0)()#将对象地址作为函数地址使用的一个范例！！？？？？？

# type()
# def __call__(self, *args, **kwargs):  # real signature unknown
#     """ Call self as a function. """
#     pass
# type类与object类   Class类与Object类
```

```python
# __getitem__ __setitem__ __delitem__



class Foo:
    def __init__(self, name):
        self.name = name

    # python相比于java在get set上简化了许多
    def __getitem__(self, item):
        return self.__dict__[item]

    def __setitem__(self, key, value):
        self.__dict__[key] = value

    def __delitem__(self, key):
        print("del obj[key]时执行")
        self.__dict__.pop(key)

    def __delattr__(self, item):
        print("del obj.key时执行")
        self.__dict__.pop(item)


f = Foo("张三")

f.age = 18

del f.age
del f['name']
```

```python
# 更正 __init__为初始化方法，并非构造方法，构造方法为__new__，析构方法确实是__del__
"""
__init__，初始化变量
__new__，构造函数
"""
class A:
    def __init__(self,a):
        self.a = a
        print("初始化")
    def __new__(cls, *args, **kwargs):
        print("构造函数")


o = A(1)

print(o.a)
```

```python
"""
__init__，初始化变量
__new__，构造函数
"""
class A:
    def __init__(self, a):
        self.a = a
        print("初始化")

    def __new__(cls, *args, **kwargs):
        print("构造函数")
        return object.__new__(cls)


o = A(1)
print(o.a)

# 可以和study_57相比较


# __new__
# __init__
# __init__中self.a= 1调用__setitem__
# 完成了
```

```python
"""
__eq__
__hash__
"""

class A(object):
    def __init__(self, a):
        self.a = a


o1 = A(1)
o2 = A(1)

print(o1 == o2)

print(o1 is o2)

print(o1.__eq__(o2))


class B:
    def __init__(self, b):
        self.b = b

    def __eq__(self, other):
        return self.b == other.b


b1 = B(1)
b2 = B(1)

print(b1 == b2)

print(b1 is b2)

print(b1.__eq__(b2)) ## ==与__eq__是一致的


# hash() __hash__

class C:
    def __init__(self, c):
        self.c = c

    def __eq__(self, other):
        return self.c == other.c

    def __hash__(self):
        return self.c.__hash__()

c1 = C(1)
c2 = C(1)

print(c1 == c2)

print(c1 is c2)

print(c1.__eq__(c2))
```


```python
# Annotation
# Java注解，继承Annotation接口的接口

# python abc模块

# Abstract Base Class，抽象基类


# Python Enhancement Proposals，PEP，python完善提案
# https://www.python.org/dev/peps/
# https://www.cnblogs.com/abella/p/10056875.html


# __all__、import *
"""
如果模块中没有定义 __all__，执行 from XXX import * 的时候会将模块中非下划线开头的成员都导入当前命名空间中，这样就有可能弄脏当前命名空间，
调试容易产生问题。 如果显式声明了 __all__，import * 就只会导入 __all__ 列出的成员。
"""


# with...语句是try-finally语句的简写，可以替代try-finally的功能。


# pyi文件
```

```python
# python多继承中子类调用父类的同名方法
# 1.类名调用
# 2.super


# 在python里凡是继承了object的类，都是新式类。 Python2里面继承object的是新式类，没有写父类的是经典类。 Python3里只有新式类

# 元类


# Generator expression 生成器表达式

# 内置函数

# https://blog.csdn.net/lemonbit/article/details/115153134

# https://docs.python.org/zh-cn/3.8/library/functions.html#slic


# 最全库

# https://blog.csdn.net/weixin_41599858/article/details/106890744
# https://blog.csdn.net/qq_40674583/article/details/81940974



# collections
# https://zhuanlan.zhihu.com/p/343747724
# https://docs.python.org/zh-cn/3/library/collections.html#module-collections

# 鸭子类型
# 鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由"当前方法和属性的集合"决定。
# “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”


# 夏令时，（ Daylight (日光) Saving Time：DST），也叫夏时制，又称“日光节约时制”和“夏令时间”，是一种为节约能源而人为规定地方时间的制度，在这一制度实行期间所采用的统一时间称为“夏令时间”。一般在天亮早的夏季人为将时间调快一小时，可以使人早起早睡，减少照明量，以充分利用光照资源，从而节约照明用电。各个采纳夏时制的国家具体规定不同。全世界有近110个国家每年要实行夏令时。

# @wraps(func)
# https://blog.csdn.net/weixin_44786530/article/details/91458106


```

```python
d = {'A': 1, 'B': 2, 'C': 3}

print(d['A'])
ds = 'A'
print(d.ds)

"""

关于attribute与property在python的区分的两种尝试性解释

1.
tribute带有致敬，贡品，悼念等具有宗教意思和神学思想的意思，本身就是比较抽象的
Proper是正常的，独特的，适当的，弥撒，章节等，是更贴近于生活，是抽象的宗教和神学思想的具体化
可以理解为attribute是所有属性的统称，具体描述某一个属性时用property更准确，但用attribute无伤大雅

2.property有财产所有权的意思，使用property特别指出这是一个特别的属性


解决Pandas的to_excel()写入不同Sheet，而不会被重写
https://cloud.tencent.com/developer/article/1764213

csv只能有一页


python测试用例覆盖率工具coverage教程(命令行工具)（译）
"""
```