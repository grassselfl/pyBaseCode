# 粘包问题

# 1.长连接：Client方与Server方先建立通讯连接，连接建立后不断开， 然后再进行报文发送和接收。
# 2.短连接：Client方与Server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此种方式常用于一点对多点通讯，比如多个Client连接一个Server.


# 粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。

# 粘包出现原因：在流传输中出现，UDP不会出现粘包，因为它有消息边界
# TCP会出现
# 1 发送端需要等缓冲区满才发送出去，造成粘包，Nagle算法
# 2 接收方不及时接收缓冲区的包，造成多个包接收
# TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。


# 粘包的处理方式：
# （1）当时短连接的情况下，不用考虑粘包的情况
# （2）如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包
# （3）如果双方建立长连接，需要在连接后一段时间内发送不同结构数据
#
# （4）处理
    # （1）发送方
    #
    # 对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。
    #
    # （2）接收方
    #
    # 接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。
    #
    # 应用层（理应？？）
    #
    # 应用层的解决办法简单可行，不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题。
    #
    # 解决办法：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长度呢？
    #
    # 格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。
    # 发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。


# 总结
# TCP 协议粘包问题是因为应用层协议开发者的错误设计导致的，他们忽略了 TCP 协议数据传输的核心机制 — 基于字节流，其本身不包含消息、数据包等概念，
# 所有数据的传输都是流式的，需要应用层协议自己设计消息的边界，即消息帧（Message Framing），我们重新回顾一下粘包问题出现的核心原因：
# TCP 协议是基于字节流的传输层协议，其中不存在消息和数据包的概念；
# 应用层协议没有使用基于长度或者基于终结符的消息边界，导致多个消息的粘连；



# struck模块